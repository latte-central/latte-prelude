<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-prelude.prop documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-prelude</span> <span class="project-version">1.0b3-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-prelude</span></div></div></li><li class="depth-2 branch"><a href="latte-prelude.classic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>classic</span></div></a></li><li class="depth-2 branch"><a href="latte-prelude.equal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>equal</span></div></a></li><li class="depth-2 branch"><a href="latte-prelude.fun.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fun</span></div></a></li><li class="depth-2 branch current"><a href="latte-prelude.prop.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>prop</span></div></a></li><li class="depth-2"><a href="latte-prelude.quant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quant</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-prelude.prop.html#var-.3C.3D.3E"><div class="inner"><span>&lt;=&gt;</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-absurd"><div class="inner"><span>absurd</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-absurd-intro"><div class="inner"><span>absurd-intro</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and"><div class="inner"><span>and</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and*"><div class="inner"><span>and*</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and*-arity"><div class="inner"><span>and*-arity</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-elim*"><div class="inner"><span>and-elim*</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-elim-left"><div class="inner"><span>and-elim-left</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-elim-left-thm"><div class="inner"><span>and-elim-left-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-elim-right"><div class="inner"><span>and-elim-right</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-elim-right-thm"><div class="inner"><span>and-elim-right-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-intro"><div class="inner"><span>and-intro</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-intro*"><div class="inner"><span>and-intro*</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-intro-thm"><div class="inner"><span>and-intro-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-sym"><div class="inner"><span>and-sym</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-sym-thm"><div class="inner"><span>and-sym-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-and-unparser"><div class="inner"><span>and-unparser</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-build-and-elim"><div class="inner"><span>build-and-elim</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-build-and-intros-left-leaning"><div class="inner"><span>build-and-intros-left-leaning</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-build-and-intros-right-leaning"><div class="inner"><span>build-and-intros-right-leaning</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-build-or-intro"><div class="inner"><span>build-or-intro</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-build-r-and-elim"><div class="inner"><span>build-r-and-elim</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-decompose-and-type"><div class="inner"><span>decompose-and-type</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-decompose-iff-type"><div class="inner"><span>decompose-iff-type</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-decompose-impl-type"><div class="inner"><span>decompose-impl-type</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-decompose-or-type"><div class="inner"><span>decompose-or-type</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-elim-path"><div class="inner"><span>elim-path</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-ex-falso"><div class="inner"><span>ex-falso</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-elim-if"><div class="inner"><span>iff-elim-if</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-elim-if-thm"><div class="inner"><span>iff-elim-if-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-elim-only-if"><div class="inner"><span>iff-elim-only-if</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-elim-only-if-thm"><div class="inner"><span>iff-elim-only-if-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-intro"><div class="inner"><span>iff-intro</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-intro-thm"><div class="inner"><span>iff-intro-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-refl"><div class="inner"><span>iff-refl</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-sym"><div class="inner"><span>iff-sym</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-sym-thm"><div class="inner"><span>iff-sym-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-trans"><div class="inner"><span>iff-trans</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-iff-trans-thm"><div class="inner"><span>iff-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-impl-ignore"><div class="inner"><span>impl-ignore</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-impl-not-not"><div class="inner"><span>impl-not-not</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-impl-refl"><div class="inner"><span>impl-refl</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-impl-trans"><div class="inner"><span>impl-trans</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-impl-trans-thm"><div class="inner"><span>impl-trans-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-mk-nary-op-left-leaning"><div class="inner"><span>mk-nary-op-left-leaning</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-mk-nary-op-right-leaning"><div class="inner"><span>mk-nary-op-right-leaning</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-not"><div class="inner"><span>not</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or"><div class="inner"><span>or</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or*"><div class="inner"><span>or*</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-assoc"><div class="inner"><span>or-assoc</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-assoc-conv-thm"><div class="inner"><span>or-assoc-conv-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-assoc-thm"><div class="inner"><span>or-assoc-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-elim"><div class="inner"><span>or-elim</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-elim-thm"><div class="inner"><span>or-elim-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-intro*"><div class="inner"><span>or-intro*</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-intro-left"><div class="inner"><span>or-intro-left</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-intro-left-thm"><div class="inner"><span>or-intro-left-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-intro-right"><div class="inner"><span>or-intro-right</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-intro-right-thm"><div class="inner"><span>or-intro-right-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-not-elim-left"><div class="inner"><span>or-not-elim-left</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-not-elim-right"><div class="inner"><span>or-not-elim-right</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-not-impl-elim"><div class="inner"><span>or-not-impl-elim</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-sym"><div class="inner"><span>or-sym</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-sym-thm"><div class="inner"><span>or-sym-thm</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-or-unparser"><div class="inner"><span>or-unparser</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-r-and*"><div class="inner"><span>r-and*</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-r-and-elim*"><div class="inner"><span>r-and-elim*</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-r-and-intro*"><div class="inner"><span>r-and-intro*</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-truth"><div class="inner"><span>truth</span></div></a></li><li class="depth-1"><a href="latte-prelude.prop.html#var-truth-is-true"><div class="inner"><span>truth-is-true</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-prelude.prop</h1><div class="doc"><div class="markdown"><p>Basic definitions and theorems for (intuitionistic) propositional logic. Most natural deduction rules are provided as theorems in this namespace.</p></div></div><div class="public anchor" id="var-.3C.3D.3E"><h3>&lt;=&gt;</h3><div class="usage"><code>(&lt;=&gt; [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(and (==&gt; A B) (==&gt; B A))
</code></pre>
<p><strong>Definition</strong>: Logical equivalence or ‘if and only if’.</p></div></div></div><div class="public anchor" id="var-absurd"><h3>absurd</h3><div class="usage"><code>(absurd)</code></div><div class="doc"><div class="markdown"><pre><code>(forall [α :type] α)
</code></pre>
<p><strong>Definition</strong>: Absurdity.</p></div></div></div><div class="public anchor" id="var-absurd-intro"><h3>absurd-intro</h3><div class="usage"><code>(absurd-intro [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (not A) absurd)
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for absurdity.</p></div></div></div><div class="public anchor" id="var-and"><h3>and</h3><div class="usage"><code>(and [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [C :type] (==&gt; (==&gt; A B C) C))
</code></pre>
<p><strong>Definition</strong>: logical conjunction.</p></div></div></div><div class="public anchor" id="var-and*"><h3>and*</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A notation defining an n-ary variant of <a href="latte-prelude.prop.html#var-and">and</a>, which exploits the fact that conjunction is associative. By default we use the leaf-leaning expansion:</p>
<pre><code>(and* p1 p2 ... pN-1 pN) ≡ (and (and ... (and p1 p2) pN-1) pN)))
</code></pre>
<p>We favor this variant because it is often the case that we use conjunction for a form of “subclassing”. Consider some mathematical <code>&lt;object&gt;</code> defined as having some properties <code>(and p1 p2)</code> (e.g. a preorder with reflexivity and transitivity). Then we might “subclass” such an object by considering a supplementary property, i.e. we want <code>(and &lt;object&gt; p3)</code> (e.g. a preorder with antisymetry hence a partial order). This is exactly <code>(and (and p1 p2) p3)</code>,  and if it is of course isomorphic to the right-leaning version <code>(and p1 (and p2 p3))</code>, only the left variant reflects the “subclassing” aspect.<br />A right-leaning nary conjunction is provided by <a href="latte-prelude.prop.html#var-r-and*">r-and*</a>. </p></div></div></div><div class="public anchor" id="var-and*-arity"><h3>and*-arity</h3><div class="usage"><code>(and*-arity def-env ctx and-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-and-elim*"><h3>and-elim*</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-elim* n and-term)</code></p>
<p>This is a generic elimination rule for n-ary  conjunction (e.g. as introduced by the <a href="latte-prelude.prop.html#var-and*">and*</a> notation). In <code>(and-elim* n and-term)</code> the index <code>n</code> corresponds to the <code>n</code>-th operand of the term.</p>
<p>For example (informally ):</p>
<ul>
  <li><code>(and-elim* 1 (and* a b c)≡(and (and a b) c)) ==&gt; a</code></li>
  <li><code>(and-elim* 2 (and* a b c)) ==&gt; b</code></li>
  <li><code>(and-elim* 3 (and* a b c)) ==&gt; c</code></li>
</ul>
<p>Internally, the correct nesting of <a href="latte-prelude.prop.html#var-and-elim-left">and-elim-left</a> and <a href="latte-prelude.prop.html#var-and-elim-right">and-elim-right</a> is constructed. Errors are raised if the index is incorrect or if the specificied term is not a conjunction.</p></div></div></div><div class="public anchor" id="var-and-elim-left"><h3>and-elim-left</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-elim-left and-term)</code></p>
<p>An implicit elimination rule that takes a proof of type <code>(and A B)</code> and yields a proof of <code>A</code>.</p>
<p>This is an implicit version of <a href="latte-prelude.prop.html#var-and-elim-left-thm">and-elim-left-thm</a>.</p></div></div></div><div class="public anchor" id="var-and-elim-left-thm"><h3>and-elim-left-thm</h3><div class="usage"><code>(and-elim-left-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) A)
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical conjunction.  This one only keeps the left-side of the conjunction</p></div></div></div><div class="public anchor" id="var-and-elim-right"><h3>and-elim-right</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-elim-right and-term)</code></p>
<p>An implicit elimination rule that takes a proof <code>and-term</code> of type <code>(and A B)</code> and yields a proof of <code>B</code>.</p>
<p>This is an implicit version of <a href="latte-prelude.prop.html#var-and-elim-right-thm">and-elim-right-thm</a>.</p></div></div></div><div class="public anchor" id="var-and-elim-right-thm"><h3>and-elim-right-thm</h3><div class="usage"><code>(and-elim-right-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) B)
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical conjunction.  This one only keeps the right-side of the conjunction</p></div></div></div><div class="public anchor" id="var-and-intro"><h3>and-intro</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-intro a b)</code></p>
<p>An introduction rule that takes a proof <code>a</code> of type <code>A</code>, a proof <code>b</code> of type <code>B</code> and yields a proof of type <code>(and A B)</code>.</p>
<p>This is an implicit version of <a href="latte-prelude.prop.html#var-and-intro-thm">and-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-and-intro*"><h3>and-intro*</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A nary variant of <a href="latte-prelude.prop.html#var-and-intro">and-intro</a>, the introduction rule for conjunction. It builds a proof of <code>(and* A1 A2 ... AN)</code> from proofs of the <code>Ai</code>’s</p></div></div></div><div class="public anchor" id="var-and-intro-thm"><h3>and-intro-thm</h3><div class="usage"><code>(and-intro-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A B (and A B))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for logical conjunction.</p></div></div></div><div class="public anchor" id="var-and-sym"><h3>and-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(and-sym and-term)</code></p>
<p>Symmetry of conjunction, an implicit version of <a href="null">and-sym-</a>.</p></div></div></div><div class="public anchor" id="var-and-sym-thm"><h3>and-sym-thm</h3><div class="usage"><code>(and-sym-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (and A B) (and B A))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of conjunction.</p></div></div></div><div class="public anchor" id="var-and-unparser"><h3>and-unparser</h3><div class="usage"><code>(and-unparser term)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-build-and-elim"><h3>build-and-elim</h3><div class="usage"><code>(build-and-elim def-env ctx n and-term and-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-build-and-intros-left-leaning"><h3>build-and-intros-left-leaning</h3><div class="usage"><code>(build-and-intros-left-leaning args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-build-and-intros-right-leaning"><h3>build-and-intros-right-leaning</h3><div class="usage"><code>(build-and-intros-right-leaning args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-build-or-intro"><h3>build-or-intro</h3><div class="usage"><code>(build-or-intro args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-build-r-and-elim"><h3>build-r-and-elim</h3><div class="usage"><code>(build-r-and-elim def-env ctx n and-term and-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-and-type"><h3>decompose-and-type</h3><div class="usage"><code>(decompose-and-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-iff-type"><h3>decompose-iff-type</h3><div class="usage"><code>(decompose-iff-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-impl-type"><h3>decompose-impl-type</h3><div class="usage"><code>(decompose-impl-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-decompose-or-type"><h3>decompose-or-type</h3><div class="usage"><code>(decompose-or-type def-env ctx t)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-elim-path"><h3>elim-path</h3><div class="usage"><code>(elim-path l r n arity)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-ex-falso"><h3>ex-falso</h3><div class="usage"><code>(ex-falso [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; absurd A)
</code></pre>
<p><strong>Theorem</strong>: Ex falso sequitur quodlibet  (proof by contradiction, elimination for absurdity).</p></div></div></div><div class="public anchor" id="var-iff-elim-if"><h3>iff-elim-if</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-elim-if iff-term)</code></p>
<p>Left (if) elimination for <code>&lt;=&gt;</code>, an implicit version of <a href="latte-prelude.prop.html#var-iff-elim-if-thm">iff-elim-if-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-elim-if-thm"><h3>iff-elim-if-thm</h3><div class="usage"><code>(iff-elim-if-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (==&gt; A B))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical equivalence.  This one only keeps the if part of the equivalence.</p></div></div></div><div class="public anchor" id="var-iff-elim-only-if"><h3>iff-elim-only-if</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-elim-only-if iff-term)</code></p>
<p>Right (only if) elimination for <code>&lt;=&gt;</code>, an implicit version of <a href="latte-prelude.prop.html#var-iff-elim-only-if-thm">iff-elim-only-if-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-elim-only-if-thm"><h3>iff-elim-only-if-thm</h3><div class="usage"><code>(iff-elim-only-if-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (==&gt; B A))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical equivalence.  This one only keeps the only-if part of the equivalence.</p></div></div></div><div class="public anchor" id="var-iff-intro"><h3>iff-intro</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-intro ab ba)</code></p>
<p>Introduction rule for logical equivalence, an implicit version of <a href="latte-prelude.prop.html#var-iff-intro-thm">iff-intro-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-intro-thm"><h3>iff-intro-thm</h3><div class="usage"><code>(iff-intro-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (==&gt; A B) (==&gt; B A) (&lt;=&gt; A B))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-refl"><h3>iff-refl</h3><div class="usage"><code>(iff-refl [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; A A)
</code></pre>
<p><strong>Theorem</strong>: Reflexivity of logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-sym"><h3>iff-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-sym iff-term)</code></p>
<p>Symmetry of <code>&lt;=&gt;</code>, an implicit version of <a href="latte-prelude.prop.html#var-iff-sym-thm">iff-sym-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-sym-thm"><h3>iff-sym-thm</h3><div class="usage"><code>(iff-sym-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (&lt;=&gt; B A))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of logical equivalence.</p></div></div></div><div class="public anchor" id="var-iff-trans"><h3>iff-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(iff-trans iff-term1 iff-term2)</code></p>
<p>Transitivity of <code>&lt;=&gt;</code>, an implicit version of <a href="latte-prelude.prop.html#var-iff-trans-thm">iff-trans-thm</a>.</p></div></div></div><div class="public anchor" id="var-iff-trans-thm"><h3>iff-trans-thm</h3><div class="usage"><code>(iff-trans-thm [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (&lt;=&gt; A B) (&lt;=&gt; B C) (&lt;=&gt; A C))
</code></pre>
<p><strong>Theorem</strong>: Transitivity of logical equivalence.</p></div></div></div><div class="public anchor" id="var-impl-ignore"><h3>impl-ignore</h3><div class="usage"><code>(impl-ignore [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A B A)
</code></pre>
<p><strong>Theorem</strong>: A variant of reflexivity.</p></div></div></div><div class="public anchor" id="var-impl-not-not"><h3>impl-not-not</h3><div class="usage"><code>(impl-not-not [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (not (not A)))
</code></pre>
<p><strong>Theorem</strong>: The if half of double negation.</p>
<p>This can be seen as an introduction rule for ¬¬ (not-not) propositions. Note that double-negation is a law of classical (non-intuitionistic) logic.</p></div></div></div><div class="public anchor" id="var-impl-refl"><h3>impl-refl</h3><div class="usage"><code>(impl-refl [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A A)
</code></pre>
<p><strong>Theorem</strong>: Implication is reflexive.</p></div></div></div><div class="public anchor" id="var-impl-trans"><h3>impl-trans</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(impl-trans impl1 impl2)</code></p></div></div></div><div class="public anchor" id="var-impl-trans-thm"><h3>impl-trans-thm</h3><div class="usage"><code>(impl-trans-thm [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (==&gt; A B) (==&gt; B C) (==&gt; A C))
</code></pre>
<p><strong>Theorem</strong>: Implication is transitive.</p></div></div></div><div class="public anchor" id="var-mk-nary-op-left-leaning"><h3>mk-nary-op-left-leaning</h3><div class="usage"><code>(mk-nary-op-left-leaning op args)</code></div><div class="doc"><div class="markdown"><p>A simple utility for creating “left-leaning” n-ary operator calls. Remark: the <code>args</code> are reverted in input.</p></div></div></div><div class="public anchor" id="var-mk-nary-op-right-leaning"><h3>mk-nary-op-right-leaning</h3><div class="usage"><code>(mk-nary-op-right-leaning op args)</code></div><div class="doc"><div class="markdown"><p>A simple utility for creating “right-leaning” n-ary operator calls.</p></div></div></div><div class="public anchor" id="var-not"><h3>not</h3><div class="usage"><code>(not [A :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A absurd)
</code></pre>
<p><strong>Definition</strong>: Logical negation.</p></div></div></div><div class="public anchor" id="var-or"><h3>or</h3><div class="usage"><code>(or [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [C :type] (==&gt; (==&gt; A C) (==&gt; B C) C))
</code></pre>
<p><strong>Definition</strong>: logical disjunction.</p></div></div></div><div class="public anchor" id="var-or*"><h3>or*</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A notation defining an n-ary variant of <a href="latte-prelude.prop.html#var-or">or</a>, which exploits the fact that disjunction is associative. By convention we have:</p>
<pre><code>(or* p1 p2 ... pN-1 pN) ≡ (or p1 (or p2 (or ... (or pN-1 pN))))
</code></pre></div></div></div><div class="public anchor" id="var-or-assoc"><h3>or-assoc</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-assoc or-term)</code></p>
<p>Associativity of disjunction, an implicit that subsumes both <a href="latte-prelude.prop.html#var-or-assoc-thm">or-assoc-thm</a> and <a href="latte-prelude.prop.html#var-or-assoc-conv-thm">or-assoc-conv-thm</a>.</p></div></div></div><div class="public anchor" id="var-or-assoc-conv-thm"><h3>or-assoc-conv-thm</h3><div class="usage"><code>(or-assoc-conv-thm [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A (or B C)) (or (or A B) C))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-or-assoc-thm"><h3>or-assoc-thm</h3><div class="usage"><code>(or-assoc-thm [A :type] [B :type] [C :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or (or A B) C) (or A (or B C)))
</code></pre>
<p><strong>Theorem</strong>: </p></div></div></div><div class="public anchor" id="var-or-elim"><h3>or-elim</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-elim or-term prop left-proof right-proof)</code></p>
<p>An elimination rule that takes a proof  <code>or-term</code> of type <code>(or A B)</code>, a proposition <code>prop</code>, a proof <code>left-proof</code> of type <code>(==&gt; A prop)</code>, a proof <code>right-proof</code> of type <code>(==&gt; B prop)</code>, and thus concludes that <code>prop</code> holds by <code>[[or-elim-thm]]</code>.</p>
<p>This is (for now) the easiest rule to use for proof-by-cases.</p></div></div></div><div class="public anchor" id="var-or-elim-thm"><h3>or-elim-thm</h3><div class="usage"><code>(or-elim-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (forall [C :type] (==&gt; (==&gt; A C) (==&gt; B C) C)))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for logical disjunction. This corresponds to a important scheme of reasoning by cases. To prove a proposition <code>C</code> under the assumption <code>(or A B)</code>:  - first case: assume <code>A</code> and prove <code>C</code>  - second case: assume <code>B</code> and prove <code>C</code></p></div></div></div><div class="public anchor" id="var-or-intro*"><h3>or-intro*</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A generic introduction rule for <a href="latte-prelude.prop.html#var-or*">or*</a>. Suppose we have a proof <code>p</code> of a proposition <code>Ai</code>, and suppose also the sequence of types <code>A1</code>,…,<code>Ai</code>,…,<code>An</code>.</p>
<p>Then <code>(or-intro* A1 ... p ... An)</code> is a proof of <code>(or* A1 ... Ai ... An)</code>.</p></div></div></div><div class="public anchor" id="var-or-intro-left"><h3>or-intro-left</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-intro-left left-term right-type)</code></p>
<p>Left introduction for disjunction, an implicit version of <a href="latte-prelude.prop.html#var-or-intro-left-thm">or-intro-left-thm</a>.</p></div></div></div><div class="public anchor" id="var-or-intro-left-thm"><h3>or-intro-left-thm</h3><div class="usage"><code>(or-intro-left-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; A (or A B))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for logical disjunction. This is the introduction by the left operand.</p></div></div></div><div class="public anchor" id="var-or-intro-right"><h3>or-intro-right</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-intro-right left-type right-term)</code></p>
<p>Right introduction for disjunction, an implicit version of <a href="latte-prelude.prop.html#var-or-intro-right-thm">or-intro-right-thm</a>.</p></div></div></div><div class="public anchor" id="var-or-intro-right-thm"><h3>or-intro-right-thm</h3><div class="usage"><code>(or-intro-right-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; B (or A B))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for logical disjunction. This is the introduction by the right operand.</p></div></div></div><div class="public anchor" id="var-or-not-elim-left"><h3>or-not-elim-left</h3><div class="usage"><code>(or-not-elim-left [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (not B) A)
</code></pre>
<p><strong>Theorem</strong>: An elimination rule for disjunction, simpler than <a href="latte-prelude.prop.html#var-or-elim">or-elim</a>. This eliminates to the left operand.</p></div></div></div><div class="public anchor" id="var-or-not-elim-right"><h3>or-not-elim-right</h3><div class="usage"><code>(or-not-elim-right [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (not A) B)
</code></pre>
<p><strong>Theorem</strong>: An elimination rule for disjunction, simpler than <a href="latte-prelude.prop.html#var-or-elim">or-elim</a>. This eliminates to the right operand.</p></div></div></div><div class="public anchor" id="var-or-not-impl-elim"><h3>or-not-impl-elim</h3><div class="usage"><code>(or-not-impl-elim [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (==&gt; (not A) B))
</code></pre>
<p><strong>Theorem</strong>: An alternative elimination rule for disjunction.</p></div></div></div><div class="public anchor" id="var-or-sym"><h3>or-sym</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(or-sym or-term)</code></p>
<p>Symmetry of disjunction, an implicit version of <a href="latte-prelude.prop.html#var-or-sym-thm">or-sym-thm</a>.</p></div></div></div><div class="public anchor" id="var-or-sym-thm"><h3>or-sym-thm</h3><div class="usage"><code>(or-sym-thm [A :type] [B :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (or A B) (or B A))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of disjunction.</p></div></div></div><div class="public anchor" id="var-or-unparser"><h3>or-unparser</h3><div class="usage"><code>(or-unparser term)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-r-and*"><h3>r-and*</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A notation defining an n-ary variant of <a href="latte-prelude.prop.html#var-and">and</a>, which exploits the fact that conjunction is associative. This version is the right-leaning variant of <a href="latte-prelude.prop.html#var-and*">and*</a>, which means the following:</p>
<pre><code>(and* p1 p2 ... pN-1 pN) ≡ (and p1 (and p2 (and ... (and pN-1 pN))))
</code></pre></div></div></div><div class="public anchor" id="var-r-and-elim*"><h3>r-and-elim*</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>
(r-and-elim* n and-term)</code></p>
<p>This is a generic elimination rule for (right-leaning) n-ary  conjunction (e.g. as introduced by the <a href="latte-prelude.prop.html#var-r-and*">r-and*</a> notation). In <code>(r-and-elim* n r-and-term)</code> the index <code>n</code> corresponds to the <code>n</code>-th operand of the term.</p>
<p>This is the right-leaning version of the default <a href="latte-prelude.prop.html#var-and-elim*">and-elim*</a>.</p></div></div></div><div class="public anchor" id="var-r-and-intro*"><h3>r-and-intro*</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A nary “right-leaning” variant of <a href="latte-prelude.prop.html#var-and-intro">and-intro</a>, the introduction rule for conjunction. It builds a proof of <code>(r-and* A1 A2 ... AN)</code> from proofs of the <code>Ai</code>’s</p>
<p>Remark: the default “left-leaning” varient is <a href="latte-prelude.prop.html#var-and-intro*">and-intro*</a>.</p></div></div></div><div class="public anchor" id="var-truth"><h3>truth</h3><div class="usage"><code>(truth)</code></div><div class="doc"><div class="markdown"><pre><code>(not absurd)
</code></pre>
<p><strong>Definition</strong>: Logical truth.</p></div></div></div><div class="public anchor" id="var-truth-is-true"><h3>truth-is-true</h3><div class="usage"><code>(truth-is-true)</code></div><div class="doc"><div class="markdown"><pre><code>truth
</code></pre>
<p><strong>Theorem</strong>: The truth is true (really ?).</p></div></div></div></div></body></html>